// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enum for Unit Types (Optional but helpful)
enum UnitType {
  WEIGHT
  VOLUME
  COUNT
  OTHER
}

model Category {
  id          Int      @id @default(autoincrement())
  name        String   @db.VarChar(150)
  description String?  @db.Text
  userId      Int      @map("user_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relation: One category has many recipes
  recipes     Recipe[]
  author      User     @relation("UserRecipeCategories", fields: [userId], references: [id], onDelete: Cascade)

  @@map("categories")
  @@index([userId])
  @@unique([name, userId])
}

// Add Ingredient Category model
model IngredientCategory {
  id          Int      @id @default(autoincrement())
  name        String   @db.VarChar(150)
  description String?  @db.Text
  userId      Int      @map("user_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relation: One category has many ingredients
  ingredients Ingredient[]
  author      User     @relation("UserIngredientCategories", fields: [userId], references: [id], onDelete: Cascade)

  @@map("ingredient_categories")
  @@index([userId])
  @@unique([name, userId])
}

model UnitOfMeasure {
  id           Int                 @id @default(autoincrement())
  name         String              @db.VarChar(100)
  abbreviation String?             @db.VarChar(20)
  type         UnitType?           // Optional enum type
  userId       Int                 @map("user_id")
  createdAt    DateTime            @default(now()) @map("created_at")
  updatedAt    DateTime            @updatedAt @map("updated_at")

  // Relations
  recipesYield       Recipe[]            @relation("RecipeYieldUnit")
  recipeIngredients UnitQuantity[]      @relation("RecipeIngredientUnit")
  author       User                @relation("UserUnits", fields: [userId], references: [id], onDelete: Cascade)

  @@map("units_of_measure")
  @@index([userId])
  @@unique([name, userId])
  @@unique([abbreviation, userId])
}

model Ingredient {
  id          Int              @id @default(autoincrement())
  name        String           @db.VarChar(255)
  description String?          @db.Text

  // Add relation to IngredientCategory (optional)
  ingredientCategoryId Int?     @map("ingredient_category_id")
  userId      Int              @map("user_id")
  ingredientCategory   IngredientCategory? @relation(fields: [ingredientCategoryId], references: [id], onDelete: SetNull)
  author               User                @relation("UserIngredients", fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  // Relation to recipe ingredients
  recipeIngredients UnitQuantity[]   @relation("RecipeIngredientBase")

  @@map("ingredients")
  @@index([ingredientCategoryId]) // Add index
  @@index([userId])
  @@unique([name, userId])
}

model Recipe {
  id                Int              @id @default(autoincrement())
  name              String           @db.VarChar(255)
  description       String?          @db.Text
  instructions      String           @db.Text
  yieldQuantity     Decimal?         @map("yield_quantity") @db.Decimal(10, 2)
  yieldUnitId       Int?             @map("yield_unit_id")
  prepTimeMinutes   Int?             @map("prep_time_minutes")
  cookTimeMinutes   Int?             @map("cook_time_minutes")
  tags              String[]         @db.Text 
  categoryId        Int?             @map("category_id")
  
  // Add userId to associate recipe with a user - MAKE OPTIONAL FOR MIGRATION
  userId            Int              @map("user_id")

  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @updatedAt @map("updated_at")

  // Relations
  category          Category?        @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  yieldUnit         UnitOfMeasure?   @relation("RecipeYieldUnit", fields: [yieldUnitId], references: [id], onDelete: SetNull)
  recipeIngredients UnitQuantity[]   @relation("RecipeParent") 
  usedAsSubRecipe   UnitQuantity[]   @relation("RecipeSubComponent") 
  author            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("recipes")
  @@index([categoryId])
  @@index([userId]) // Add index for user relation
}

// Explicit Many-to-Many / Linking Table for Recipe Ingredients & Sub-Recipes
model UnitQuantity {
  id            Int      @id @default(autoincrement())
  recipeId      Int      @map("recipe_id") // The recipe this ingredient belongs to
  ingredientId  Int?     @map("ingredient_id") // The base ingredient (nullable)
  subRecipeId   Int?     @map("sub_recipe_id") // The sub-recipe used as an ingredient (nullable)
  quantity      Decimal  @db.Decimal(10, 2)
  unitId        Int      @map("unit_id") // Unit for this specific line item quantity
  order         Int      @default(0)
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  recipe        Recipe         @relation("RecipeParent", fields: [recipeId], references: [id], onDelete: Cascade)
  ingredient    Ingredient?    @relation("RecipeIngredientBase", fields: [ingredientId], references: [id], onDelete: Restrict)
  subRecipe     Recipe?        @relation("RecipeSubComponent", fields: [subRecipeId], references: [id], onDelete: Restrict)
  unit          UnitOfMeasure  @relation("RecipeIngredientUnit", fields: [unitId], references: [id], onDelete: Restrict)

  // @@unique([recipeId, ingredientId]) // Can't use if ingredientId is nullable
  // @@unique([recipeId, subRecipeId]) // Can't use if subRecipeId is nullable
  // Need to handle uniqueness constraint at the application or database trigger level if needed
  // e.g., ensure you don't add the same ingredient twice to the same recipe.

  @@map("recipe_ingredients")
  @@index([recipeId])
  @@index([ingredientId])
  @@index([subRecipeId])
  @@index([unitId])
}

// --- User Model ---
enum UserRole {
  USER
  ADMIN
  SUPERADMIN
}

model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  name        String?
  password    String   
  role        UserRole   @default(USER)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relation back to Recipe (remains the same, one user can have many recipes)
  recipes     Recipe[]
  units              UnitOfMeasure[]      @relation("UserUnits")
  ingredients        Ingredient[]         @relation("UserIngredients")
  recipeCategories   Category[]           @relation("UserRecipeCategories")
  ingredientCategories IngredientCategory[] @relation("UserIngredientCategories")

  @@map("users")
}
